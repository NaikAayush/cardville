// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

struct Player {
    address addr;
    uint stake;
    bool active;
}

struct Card {
    uint hp;
    uint atk;
}

struct Round {
    Card[] p1_table;
    Card[] p2_table;
}

struct Match {
    Player p1;
    Player p2;
    Round[] rounds;
}

contract MatchMaking is KeeperCompatibleInterface {
    Player[] queue;
    mapping(uint256 => Match) matches; 
    function joinQueue(address addr, uint stake) public {
        Player memory player = Player(addr, stake, true);
        queue.push(player);
    }

    function getIndexOfPlayer(address addr) private view returns (uint id) {
        for(uint i = queue.length - 1; i >= 0; i--) {
            if (queue[i].addr == addr) {
                return i;
            }
        }
    }

    function getMatch(address addr, uint stake) public returns (Player memory opponent) {
        uint opponentIndex;
        for(uint i = queue.length - 1; i >= 0; i--) {
            if (queue[i].active && queue[i].stake == stake && queue[i].addr != addr) {
                opponentIndex = i;
            }
        }

        // TODO: error handling if opponentIndex go brr?
        queue[opponentIndex].active = false;
        queue[getIndexOfPlayer(addr)].active = false;
        return queue[opponentIndex];
    }

    event PublishMatchId(address p1, address p2, uint256 matchId);

    function generateMatchID() private view returns (uint256 hash) {
        return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));
    }

    function pairOpponents() public {
        for(uint i = 0; i < queue.length; i++) {
            if (queue[i].active) {
                Player memory p1 = queue[i];
                Player memory p2 = getMatch(p1.addr, p1.stake);
                // create matchid, and add to matches map
                uint256 matchId = generateMatchID();
                matches[matchId] = Match(p1, p2, new Round[](0));
                emit PublishMatchId(p1.addr, p2.addr, matchId);
            }
        }
    }
    /**
    * Public counter variable
    */
    uint public counter;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval) {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;

      counter = 0;
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            pairOpponents();
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

}
